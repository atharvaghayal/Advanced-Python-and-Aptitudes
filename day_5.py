# -*- coding: utf-8 -*-
"""Day_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QzwBhp46LVMKFfrKt8-3eZPWauUldBHE
"""

#Call by value python code.
def modify_value(x):
  x=x+5
  print("Inside function: ",x)
num=10
modify_value(num)
print("Outside function: ",num)

#call by reference python code.
def modify_list(lst):
  lst.append(100)
  print("Inside function: ",lst)
numbers=[1,2,3]
print("Outside function: ",numbers)
modify_list(numbers)
print("Outside function: ",numbers)

#recursion using python.
def factorial(n):
  if n==0 or n==1:
    return 1
  else:
    return n*factorial(n-1)
#code in main function
no=int(input("Enter any number: "))
res=fact(no)
print("fact is: ",res)

#Multiply 2 numbers using recursion.
def mul(x,y):
  if x==0 or y==0:
    return 0;
  elif x==1:
    return y;
  elif y==1:
    return x;
  else:
    return x+mul(x,y-1)
no1=int(input("Enter first number: "))
no2=int(input("Enter second number: "))
res=mul(no1,no2)
print("Multiplication is: ",res)

#Sum n numbers.
def sum(n):
  if x==0 or y==0:
    return 0;
  elif x==1:
    return y;
  elif y==1:
    return x;
  else:
    return n+sum(x,y-1)

#print factors in python
n=int(input("Enter a number: "))
m=int(input("Enter a number: "))
for i in range(1,n+1):
  if n%i==0:
    print(i)

#find GCD using python
def gcd(a,b):
  if b==0:
    return a
  else:
    return gcd(b,a%b)

#Lamda function
def square(n):
  return n*n
s=Lamda n: n*n
print(s(10))

#WAP Lamda function for sum of 2 numbers
def square(n,m):
  return n+m
def square(n,m):
  return n+m;

#find the next larger element in list using loop in pyhton
numbers = list(map(int, input("Enter numbers separated by spaces: ").split()))
next_larger = []
for i in range(len(numbers)):
    for j in range(i+1,len(numbers)):
        if numbers[j] > numbers[i]:
            next_larger.append(numbers[j])
            break;

next_larger.append(-1)
print(next_larger)

#edit distance
#given 2 strings s and t.Return the minimum number of operations required to convert s to t.
def min_operations(s, t):
    n = len(s)
    m = len(t)
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        dp[i][0] = i
    for j in range(m + 1):
        dp[0][j] = j
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
    return dp[n][m]

a=10
b=0
try:
  print(a/b)
except ZeroDivisionError:
  print("you are not allowed to divide by zero")
a=10
b=0
try:
  print(a/b)
except ZeroDivisionError as msg:
  print(msg)

try:
  a=int(input("Enter a number: "))
  b=int(input("Enter a number: "))
  print(a/b)
except (ZeroDivisionError,ValueError) as msg:
  print("Please Provide valid input",msg)